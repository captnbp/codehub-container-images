stages:
  - lint
  - build
  - test
  - sign

image: captnbp/gitlab-ci-image:1.8.13

.tpl:container:test:hadolint:
  variables:
    DOCKERFILE_PATH: Dockerfile
  stage: lint
  script:
    - mkdir -p reports
    - hadolint -f gitlab_codeclimate ${DOCKERFILE_PATH} > reports/hadolint-$(md5sum ${DOCKERFILE_PATH} | cut -d" " -f1).json
  artifacts:
    name: "${CI_JOB_NAME} artifacts from ${CI_PROJECT_NAME} on ${CI_COMMIT_REF_SLUG}"
    when: always
    expire_in: "1 day"
    reports:
      codequality:
        - "reports/*"
    paths:
      - "reports/*"

.tpl:container:test:cve:
  # Requirements:
  # - A `test` stage to be present in the pipeline.
  # - You must define the image to be scanned in the CS_IMAGE variable. If CS_IMAGE is the
  #   same as $CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG, you can skip this.
  # - Container registry credentials defined by `CS_REGISTRY_USER` and `CS_REGISTRY_PASSWORD` variables if the
  # image to be scanned is in a private registry.
  # - For auto-remediation, a readable Dockerfile in the root of the project or as defined by the
  #   CS_DOCKERFILE_PATH variable.
  image: "$CI_TEMPLATE_REGISTRY_HOST/security-products/container-scanning:6$CS_IMAGE_SUFFIX"
  stage: test
  variables:
    CS_ANALYZER_IMAGE: "$CI_TEMPLATE_REGISTRY_HOST/security-products/container-scanning:6"
    CS_SCHEMA_MODEL: 15
    # To provide a `vulnerability-allowlist.yml` file, override the GIT_STRATEGY variable in your
    # `.gitlab-ci.yml` file and set it to `fetch`.
    # For details, see the following links:
    # https://docs.gitlab.com/ee/user/application_security/container_scanning/index.html#overriding-the-container-scanning-template
    # https://docs.gitlab.com/ee/user/application_security/container_scanning/#vulnerability-allowlisting
    GIT_STRATEGY: none
  allow_failure: true
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
      dependency_scanning: gl-dependency-scanning-report.json
    paths: [gl-container-scanning-report.json, gl-dependency-scanning-report.json, "**/gl-sbom-*.cdx.json"]
  dependencies: []
  script:
    - gtcs scan
  rules:
    - if: $CONTAINER_SCANNING_DISABLED == 'true' || $CONTAINER_SCANNING_DISABLED == '1'
      when: never
    - if: $CI_COMMIT_BRANCH &&
          $CI_GITLAB_FIPS_MODE == "true" &&
          $CS_ANALYZER_IMAGE !~ /-(fips|ubi)\z/
      variables:
        CS_IMAGE_SUFFIX: -fips
    - if: $CI_COMMIT_BRANCH

.tpl:container:build:kaniko:
  stage: build
  variables:
    IMAGE_NAME: ""
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
    - |
      /kaniko/executor --context ${CI_PROJECT_DIR}/${IMAGE_NAME} \
        --dockerfile Dockerfile \
        --destination ${CI_IMAGE} \
        --digest-file=/dev/termination-log \
        --image-name-with-digest-file=image-digest.txt \
        --label org.opencontainers.image.created=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
        --label "org.opencontainers.image.authors=${CI_COMMIT_AUTHOR}" \
        --label org.opencontainers.image.url=${CI_PROJECT_URL} \
        --label org.opencontainers.image.documentation=${CI_PROJECT_URL} \
        --label org.opencontainers.image.source=${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA} \
        --label org.opencontainers.image.revision=${CI_COMMIT_SHA} \
        --label "org.opencontainers.image.vendor=${CI_COMMIT_AUTHOR}" \
        --label org.opencontainers.image.licenses="MIT License" \
        --label org.opencontainers.image.title=${IMAGE_NAME}
  artifacts:
    paths:
      - image-digest.txt


.tpl:container:sign:sign-image:
  stage: sign
  script:
    - export VAULT_TOKEN="$(vault write -field=token auth/jwt/${CI_SERVER_HOST}/login role=cosign token_ttl=60 jwt=$CI_JOB_JWT)"
    - mkdir -p ${HOME}/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > ${HOME}/.docker/config.json
    - export IMAGE_DIGEST=$(cat image-digest.txt)
    - cosign sign -y --upload=true --tlog-upload=true --key hashivault://cosign ${IMAGE_DIGEST}

.tpl:container:sign:attest-image:
  stage: sign
  script:
    - export VAULT_TOKEN="$(vault write -field=token auth/jwt/${CI_SERVER_HOST}/login role=cosign token_ttl=60 jwt=$CI_JOB_JWT)"
    - mkdir -p ${HOME}/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > ${HOME}/.docker/config.json
    - export IMAGE_DIGEST=$(cat image-digest.txt)
    - echo "Scanning image digest ${IMAGE_DIGEST}"
    - skopeo inspect docker://${IMAGE_DIGEST}
    - trivy image --output /tmp/image.sbom --format cosign-vuln --ignore-unfixed --severity HIGH,CRITICAL ${IMAGE_DIGEST}
    - cosign attest -y --key  hashivault://cosign --predicate /tmp/image.sbom ${IMAGE_DIGEST}
    - cosign attach sbom --sbom /tmp/image.sbom ${IMAGE_DIGEST}

before_script:
  - |
      if [[ -z "${CI_COMMIT_TAG}" ]]; then
        export CI_APPLICATION_REPOSITORY=${CI_APPLICATION_REPOSITORY:-$CI_REGISTRY_IMAGE}/${IMAGE_NAME}
        export CI_APPLICATION_TAG=${CI_COMMIT_REF_SLUG}-${CI_APPLICATION_TAG:-$CI_COMMIT_SHA}
      else
        export CI_APPLICATION_REPOSITORY=${CI_APPLICATION_REPOSITORY:-$CI_REGISTRY_IMAGE}/${IMAGE_NAME}
        export CI_APPLICATION_TAG=${CI_APPLICATION_TAG:-$CI_COMMIT_TAG}
      fi
      export CI_IMAGE=${CI_APPLICATION_REPOSITORY}:${CI_APPLICATION_TAG}
      export CS_IMAGE=${CI_IMAGE}
      echo "Destination image ${CI_IMAGE}"

docker-build-code-server:
  extends: .tpl:container:build:kaniko
  variables:
    IMAGE_NAME: "code-server"

docker-build-nginx:
  extends: .tpl:container:build:kaniko
  variables:
    IMAGE_NAME: "nginx"

docker-build-oauth:
  extends: .tpl:container:build:kaniko
  variables:
    IMAGE_NAME: "oauth"

container_scanning-code-server:
  extends: .tpl:container:test:cve
  variables:
    IMAGE_NAME: "code-server"
  needs:
    - docker-build-code-server

container_scanning-nginx:
  extends: .tpl:container:test:cve
  variables:
    IMAGE_NAME: "nginx"
  needs:
    - docker-build-nginx

container_scanning-oauth:
  extends: .tpl:container:test:cve
  variables:
    IMAGE_NAME: "oauth"
  needs:
    - docker-build-oauth

lint-dockerfile-code-server:
  extends: .tpl:container:test:hadolint
  variables:
    DOCKERFILE_PATH: code-server/Dockerfile

lint-dockerfile-nginx:
  extends: .tpl:container:test:hadolint
  variables:
    DOCKERFILE_PATH: nginx/Dockerfile

lint-dockerfile-oauth:
  extends: .tpl:container:test:hadolint
  variables:
    DOCKERFILE_PATH: oauth/Dockerfile

sign-code-server:
  extends: .tpl:container:sign:sign-image
  variables:
    IMAGE_NAME: "code-server"
  needs:
    - docker-build-code-server

sign-nginx:
  extends: .tpl:container:sign:sign-image
  variables:
    IMAGE_NAME: "nginx"
  needs:
    - docker-build-nginx

sign-oauth:
  extends: .tpl:container:sign:sign-image
  variables:
    IMAGE_NAME: "oauth"
  needs:
    - docker-build-oauth

attest-code-server:
  extends: .tpl:container:sign:attest-image
  variables:
    IMAGE_NAME: "code-server"
  needs:
    - docker-build-code-server

attest-nginx:
  extends: .tpl:container:sign:attest-image
  variables:
    IMAGE_NAME: "nginx"
  needs:
    - docker-build-nginx

attest-oauth:
  extends: .tpl:container:sign:attest-image
  variables:
    IMAGE_NAME: "oauth"
  needs:
    - docker-build-oauth